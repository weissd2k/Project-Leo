# -*- coding: utf-8 -*-
"""“IRP_continuous-flow_without_word

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cNOQlYDkiTetUTAtNfSX-QI5TLzcPUuN
"""

import numpy as np
import math
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from scipy.integrate import solve_ivp
from mpl_toolkits.axes_grid1.inset_locator import mark_inset
from mpl_toolkits.axes_grid1.inset_locator import inset_axes

def DiffEq_data(d_list,t):

  time=t;

  j = exp[0,2];         # the reactor turnover rate 
  Cinfluent = exp[0,3];     # the inflow As(III) concentration
  k = exp[0,4];         # rate constant
  Cs = exp[0,5];         # sorbent concentrations
  KF = exp[0,6];         # Freundlich constant
  n = exp[0,7];         # experimentally determined constants
  Ct,qt = d_list         # concentration of aqueous As(III) at time t ,the quantity of arsenic adsorbed at time t 
  if Ct<0.001:
    Ct=0.001           #set a minimum concentration of sorbate in the reactor to prevent the Freundlich adsorption isotherm from running an error.

  if Ct>=Cinfluent:
      Ct=Cinfluent      #control incase ode15s time intervals are too large

  
  Ct_mgL = Ct/1000         
  qt_mgg = qt/(Cs*1000)   

  rate_ads = 1000*k*Ct_mgL*Cs*((1-(qt_mgg/(KF*(Ct_mgL**(1/n)))))**2);  
  
  rate_influx = j*Cinfluent;            #calculate the rate of sorbate influx (continuous-flow systems only)
  rate_outflux = j*Ct;               #calculate the rate of sorbate outflux (continuous-flow systems only)
  dCdt=[0,0];
  dCdt[0]=-rate_ads+rate_influx-rate_outflux     #continuous treatment reactor design 
  dCdt[1] = rate_ads 
  return dCdt

def DiffEq(d_list,t):

  time=t;

  j = exp[0,2];
  Cinfluent = exp[0,3];
  k = exp[0,4];
  Cs = exp[0,5];
  KF = exp[0,6];
  n = exp[0,7];
  Ct,qt = d_list
  if Ct<0.001:
    Ct=0.001           #set a minimum concentration of sorbate in the reactor to prevent the Freundlich adsorption isotherm from running an error.

  if Ct>=Cinfluent:
      Ct=Cinfluent      #control incase ode15s time intervals are too large

  
  Ct_mgL = Ct/1000         
  qt_mgg = qt/(Cs*1000)   

  rate_ads = 1000*k*Ct_mgL*Cs*((1-(qt_mgg/(KF*(Ct_mgL**(1/n)))))**2); 
  
  rate_influx = j*Cinfluent;            #calculate the rate of sorbate influx (continuous-flow systems only)
  rate_outflux = j*Ct;               #calculate the rate of sorbate outflux (continuous-flow systems only)
  dCdt=[0,0];
  dCdt[0]=-rate_ads+rate_influx-rate_outflux
  dCdt[1] = rate_ads /Cs*1000
  return dCdt

def Result_Processing (j_flow,C_inf,Cs0,figure=True):
  number_of_experiments=1  #each experiment will have a different initial sorbate concentration (C0) 实验次数
 
  number_of_variables = 8            #counting how many rows in the array we need to store the input parameters for each kinetic plot 参数数量

  experiments = np.zeros((number_of_experiments,number_of_variables))  #each experiment refers to a single kinetic plot  54*8的矩阵（行为第几次试验，列表示参数）

  #creating the input variables for each kinetic plots

  C_init =0.01;     # ug L-1  - this is the initial concentration of aqueous sorbate in the suspension 这是悬浮液中山梨醇水溶液的初始浓度

  q_init = 0;       # ug L-1  - this is the initial concentration of adsorbed sorbate in the suspension 吸收AS的浓度

  Cs = Cs0;        #g L-1 - this is the concentration of sorbent  吸附剂浓度

  Cinfluent = C_inf;    # ppb or ug L-1 - this is the concentration of sorbate in the influent (for continuous-flow modelling)

  j = j_flow;          #this the turn-over frequency, i.e. bed volumes per minute

  k = 0.1111;     #this is the value of normalised k' (L g-1 min-1)

  KF = 5.10;      #this is the Freundlich constant (mg g-1) used to determine 'qe' at each time step

  n = 2.63;       #this is the second parameter for the Freundlich adsorption isotherm (g L-1) used to determine 'qe' at each time step
 
  tol=1e-4

  #setting the time intervals upon which data is recorded. This will be
  #overwritten later to avoid wasting computational time after breakthrough
  #has already occurred.

  t_end = 1000000;   #1440 = 1 day
  t_steps = 20000;
  t_step = t_end/t_steps;
  bv_end = t_end*j;
  tt=list(np.arange(0,t_end+1,t_step))  

  results_table=[0]*number_of_experiments
  

  for i in range(number_of_experiments) :
    experiments[i,0] = C_init;
    experiments[i,1] = q_init;
    experiments[i,2] = j;
    experiments[i,3] = Cinfluent;
    experiments[i,4] = k;
    experiments[i,5] = Cs; #exponentially increasing sorbent concentration
    experiments[i,6] = KF;
    experiments[i,7] = n;   


  for i in range(number_of_experiments): 
    global exp 
    exp = np.zeros((1,number_of_variables));
     
    exp[0,:] = experiments[i,:]
    exp_C_init = exp[0,0]
    exp_q_init = exp[0,1]
    t_end = 180000 * exp[0,5] / (exp[0,2] * exp[0,3]);  # 50000*Cs/(j*Cinf)
    if t_end<1000:
        t_end = t_end*20
    
    if t_end<500:
        t_end=t_end*5
    
    if j<0.01:
        t_end=t_end*10
    
    if figure==True:
      stepping = [i for i in range(t_steps+1)]     #collect data at shorter time intervals in the initial stages of the simulation
      stepping[0]=0
      gradient_1=1
      gradient_2=30
      for j in range(1,(t_steps+1)) :
      #change the time intervals from being evenly spaced to having a smooth
      #transition from gradient_1 to gradient_2
        stepping[j]=stepping[j-1]+(gradient_2*(stepping[j]/t_steps))+(gradient_1*((t_steps-stepping[j])/t_steps))
    
      for k in range(1,(t_steps+1)):
          #normalise the time intervals to 1 and then multiply out by the desired
          #final time
          stepping[k]=(stepping[k]/stepping[-1])*t_end;
      result = odeint(DiffEq,[exp_C_init,exp_q_init],stepping)
          
    if figure==False:
      stepping=[i for i in range(0,525600,1440)]
      result = odeint(DiffEq_data,[exp_C_init,exp_q_init],stepping)
      
    
  

    

    counter=0
    results_Ct=np.zeros((number_of_experiments,len(result[:,0])))
    results_t=np.zeros((number_of_experiments,len(stepping)))
    results_t[i,:] = stepping
    results_Ct[i,:] = result[:,0]

    for j in range(len(result[:,0])):
         if result[:,0][j]<=10.5:
           counter+=1

    results_table[i] = [results_t[i,:],results_Ct[i,:]]
  return results_table,counter

def Min_adsorbent (result_counter):
  ads=[1,10,100,1000,10000]
  results=[0]*len(result_counter)
  for i in range(len(result_counter)):
    results[i]=(365/result_counter[i])*ads[i]*0.001*40
  
  return min(results)

results_table_10000,_=Result_Processing (0.1,2000,10000)
results_table_1000,_=Result_Processing (0.1,2000,1000)
results_table_100,_=Result_Processing (0.1,2000,100)
results_table_10,_=Result_Processing (0.1,2000,10)
results_table_1,_=Result_Processing (0.1,2000,1)

length_10=len(results_table_10[0][1])
length_10000=len(results_table_10000[0][1])
length_100=len(results_table_100[0][1])
length_1000=len(results_table_1000[0][1])
length_1=len(results_table_1[0][1])

fig, ax = plt.subplots(1, 1, figsize=(16, 8))



ax.plot(results_table_1[0][0][:length_1]*0.1, results_table_1[0][1], color='r', linestyle=':', linewidth=2,
        
        )

ax.plot(results_table_10[0][0][:length_10]*1, results_table_10[0][1], color='y', linestyle=':', linewidth=2,
        
        )

ax.plot(results_table_100[0][0][:length_100]*1, results_table_100[0][1], color='b', linestyle=':', linewidth=2,
       
       )

ax.plot(results_table_1000[0][0][:length_1000]*0.1, results_table_1000[0][1], color='g', linestyle=':', linewidth=2,
       
        )

ax.plot(results_table_10000[0][0][:length_10000]*0.1, results_table_10000[0][1], color='c', linestyle=':', linewidth=2,
      
       )




ax.get_xaxis().get_major_formatter().set_scientific(False)
ax.legend(labels=['1','10','100',"1000","10000"], ncol=3,loc="center left")

plt.xscale("log")

results_table_1_5,_=Result_Processing (0.1,500,1)
results_table_10000_5,_=Result_Processing (0.1,500,10000)
results_table_1000_5,_=Result_Processing (0.1,500,1000)
results_table_100_5,_=Result_Processing (0.1,500,100)
results_table_10_5,_=Result_Processing (0.1,500,10)

length_10_5=len(results_table_10_5[0][1])
length_10000_5=len(results_table_10000_5[0][1])
length_100_5=len(results_table_100_5[0][1])
length_1000_5=len(results_table_1000_5[0][1])
length_1_5=len(results_table_1_5[0][1])

fig, ax = plt.subplots(1, 1, figsize=(16, 8))



ax.plot(results_table_1_5[0][0][:length_1_5]*0.1, results_table_1_5[0][1], color='r', linestyle=':', linewidth=2,
        
        )

ax.plot(results_table_10_5[0][0][:length_10_5]*1, results_table_10_5[0][1], color='y', linestyle=':', linewidth=2,
        
        )

ax.plot(results_table_100_5[0][0][:length_100_5]*1, results_table_100_5[0][1], color='b', linestyle=':', linewidth=2,
       
       )

ax.plot(results_table_1000_5[0][0][:length_1000_5]*0.1, results_table_1000_5[0][1], color='g', linestyle=':', linewidth=2,
       
        )

ax.plot(results_table_10000_5[0][0][:length_10000_5]*0.1, results_table_10000_5[0][1], color='c', linestyle=':', linewidth=2,
      
       )





ax.get_xaxis().get_major_formatter().set_scientific(False)
ax.legend(labels=['1','10','100',"1000","10000"], ncol=3,loc="center left")

plt.xscale("log")

_,counter_10000=Result_Processing (0.001,500,10000,False)
_,counter_1000=Result_Processing (0.001,500,1000,False)
_,counter_100=Result_Processing (0.001,500,100,False)
_,counter_10=Result_Processing (0.001,500,10,False)
_,counter_1=Result_Processing (0.001,500,1,False)

result_counter=[counter_1,counter_10,counter_100,counter_1000,counter_10000]

results=Min_adsorbent (result_counter)
print(results)